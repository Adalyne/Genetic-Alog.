# -*- coding: utf-8 -*-
"""Genetic Algo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uYUWk6aAM6LZgxOMLTyHAk5z6lhpbWid
"""

import numpy as np
import random
import math
import matplotlib.pyplot as plt

class GeneticAlogorithn:
    def __init__(self, Number=10, Dimension=3, Bitnum=8, Elite_num=2, CrossoverRate=0.9, MutationRate=0.1, MaxIteration= 10000):
        self.N = Number
        self.D = Dimension
        self.B = Bitnum
        self.n = Elite_num
        self.cr = CrossoverRate
        self.mr = MutationRate
        self.max_iter = MaxIteration

    def generationPopulation(self):
        population = list()
        for number in range(self.N):
            chrom_list = list()
            X = np.random.randint(-60,61)
            Y = np.random.randint(-50,51)
            Z = np.random.randint(-70,71)
            chrom_list.append(X)
            chrom_list.append(Y)
            chrom_list.append(Z)
            population.append(chrom_list)
        return population

    def D2B(self, num):
        bit_map = list()
        if(num<0):
            bit_map.append(1)
            zero_num = self.B-len(bin(-num)[2:])-1
            for i in range(zero_num):
                bit_map.append(0)
            for i in bin(-num)[2:]:
                bit_map.append(int(i))
        else:
            bit_map.append(0)
            zero_num = self.B-len(bin(num)[2:])-1
            for i in range(zero_num):
                bit_map.append(0)
            for i in bin(num)[2:]:
                bit_map.append(int(i))
        return bit_map

    def B2D(self, bitnum):
        dec = ''
        for i in range(1,self.B):
            dec += str(bitnum[i])
        if bitnum[0] == 0:
            return int(dec, 2)

        else:
            return -int(dec, 2)

    def Restrict(self,bit_map):
        X, Y, Z = bit_map
        if self.B2D(X)<-60:
            bit_map[0] = self.D2B(-60)
        elif self.B2D(X)>60:
            bit_map[0] = self.D2B(60)
        elif self.B2D(Y)<-50:
            bit_map[1] = self.D2B(-50)
        elif self.B2D(Y)>50:
            bit_map[1] = self.D2B(50)
        elif self.B2D(Z)<-70:
            bit_map[2] = self.D2B(-70)
        elif self.B2D(Z)>70:
            bit_map[2] = self.D2B(70)
        return bit_map

    def fitness(self, pop):
        fit_list = list()
        (x0, y0, z0) = (6, 17, 8)
        r =100
        for n in range(len(pop)):
            fit = r**2 - (pop[n][0]-x0)**2 - (pop[n][1]-y0)**2 - (pop[n][2]-z0)**2
            fit_list.append(fit**2)
        return fit_list

    def Selection(self, pop_bin, fitness):
        select_bin = pop_bin.copy()
        fitness1 = fitness.copy()
        Parents = list()
        if sum(fitness) == 0:
            for i in range(self.n):
                parent = select_bin[random.randint(0,self.N)-1]
                Parents.append(parent)
        else:
            #print('sum of fitness=',sum(fitness))
            wheel = [(1 - (fit_num/sum(fitness1)))/(self.N-1) for fit_num in fitness1]
            #print('wheel=',wheel)
            tep = 0
            Cumulist = list()
            Cumulist.append(tep)
            for i in range(len(wheel)):
                tep += wheel[i]
                Cumulist.append(tep)
            #print('Cumulist=',Cumulist)
            for i in range(self.n):
                z1 = random.uniform(0,1)
                #print('z1=',z1)
                for pick in range(len(Cumulist)-1):
                    if Cumulist[pick] <= z1 < Cumulist[pick+1]:
                        parent = select_bin[wheel.index(wheel[pick])]
                Parents.append(parent)
        return Parents

    def Mutation(self, Children):
        mr_children = list()
        for child in Children:
            z1 = random.uniform(0,1)
            #print('mr=',z1)
            if(z1<0.1):
                element_index1 = random.randint(0,self.B-1)
                element_index2 = random.randint(0,self.B-1)
                #print('exchange index = (',element_index1,element_index2,')')
                temp = child[element_index1]
                child[element_index1] = child[element_index2]
                child[element_index2] = temp
            mr_children.append(child)
        return mr_children

    #雙點交配
    def Crossover(self, Parents):
        #crossover
        def swap_gene(p1, p2, index1, index2):
            temp = p1[index1:index2]
            p1[index1:index2] = p2[index1:index2]
            p2[index1:index2] = temp
            #print('p1=',p1,'p2=',p2)
            return p1, p2
        parents = Parents.copy()
        z1 = random.uniform(0,1)
        #print('cr z1=',z1)
        if(z1<self.cr):
            z2 = random.randint(0,self.B-3)
            z3 = random.randint(z2,self.B-2)
            #print('index=', z2)
            child1 = list()
            child2 = list()
            for i in range(self.D):
                ch1, ch2 = swap_gene(Parents[0][i], Parents[1][i], z2, z3)
                child1.append(ch1)
                child2.append(ch2)
            parents = list()
            #print('Crossover=',child1,child2)
            child1 = self.Restrict(child1)
            child2 = self.Restrict(child2)
            #print('Restrict=',child1,child2)
            #Mutation
            child1 = self.Mutation(child1)
            child2 = self.Mutation(child2)
            #print('Mutation=',child1,child2)

            parents.append(child1)
            parents.append(child2)

        return parents

def main():
    ga = GeneticAlogorithn()
    print('Population Size=',ga.N,' Population Dimension=',ga.D,' Bit Diamention=', ga.B)
    #initial
    pop_dec = ga.generationPopulation()
    print('dec population=',pop_dec)

    #encoding
    pop_bin = list()
    for i in range(ga.N):
        chrom_cv=list()
        for j in range(ga.D):
            chrom_cv.append(ga.D2B(pop_dec[i][j]))
        pop_bin.append(chrom_cv)
    print('bin populaation=',pop_bin)

    #fitness
    fitness_map = ga.fitness(pop_dec)
    print('fitness map=', fitness_map)

    best_rvlist = list()
    for e in range(ga.max_iter):
        best_fitness = min(fitness_map)
        print('i=',e,'best fitness=', best_fitness)
        best_rvlist.append(best_fitness)
        Parents = ga.Selection(pop_bin, fitness_map)
        #print('Parents=', Parents)
        Children = ga.Crossover(Parents)
        #print('Children=', Children)
        pop_bin.append(Children[0])
        pop_bin.append(Children[1])
        for i in range(len(Children)):
            child = list()
            for j in range(ga.D):
                child.append(ga.B2D(Children[i][j]))
            pop_dec.append(child)

        #print('pop_dec=',pop_dec)
        #print('pop_bin',pop_bin)
        fitness_map = ga.fitness(pop_dec)
        #print('fitness map=', fitness_map)
        for i in range(len(Children)):
            worst_fitness = max(fitness_map)
            #print('worst fitness=',worst_fitness)
            pop_dec.pop(fitness_map.index(worst_fitness))
            pop_bin.pop(fitness_map.index(worst_fitness))
            fitness_map.pop(fitness_map.index(worst_fitness))

            #print('pop_dec=',pop_dec)
            #print('pop_bin=',pop_bin)

    #print(len(best_rvlist))
    #print(best_rvlist)
    plt.figure(figsize=(8,5))

    xpoints = np.array([i for i in range(0,ga.max_iter)])
    ypoints = np.array(best_rvlist)
    plt.xlabel('Iteration', fontsize=15)
    plt.ylabel('Fitness', fontsize=15)
    print(xpoints)
    print(ypoints)
    print(len(xpoints))
    plt.plot(xpoints, ypoints, label='Best Fitness')
    plt.legend()
    plt.show()

if __name__ == '__main__':
    main()